# WebCC Schema Definition File
# Format (pipe-separated):
# NAMESPACE|TYPE|NAME|FUNC_NAME|TYPES(space-separated)|JS_ACTION
# Lines starting with '#' are comments.

# ------------------------------------------------------------------------------
# DOM
# ------------------------------------------------------------------------------
dom|command|GET_BODY|get_body|RET:int32|{ if(!elements[0]) elements[0] = document.body; return 0; }
dom|command|CREATE_ELEMENT|create_element|string:tag RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const el = document.createElement(tag); elements[handle] = el; return handle; }
dom|command|SET_ATTRIBUTE|set_attribute|int32:handle string:name string:value|{ const el = elements[handle]; if(!el){ console.warn('set_attribute: unknown element handle', handle); continue; } el.setAttribute(name, value); }
dom|command|GET_ATTRIBUTE|get_attribute|int32:handle string:name RET:string|{ const el = elements[handle]; if(!el){ console.warn('get_attribute: unknown element handle', handle); return 0; } const ret = el.getAttribute(name) || ""; }
dom|command|APPEND_CHILD|append_child|int32:parent_handle int32:child_handle|{ const parent = elements[parent_handle]; const child = elements[child_handle]; if(!parent || !child){ console.warn('append_child: unknown handles', parent_handle, child_handle); continue; } parent.appendChild(child); }
dom|command|REMOVE_ELEMENT|remove_element|int32:handle|{ const el = elements[handle]; if(!el){ console.warn('remove_element: unknown element handle', handle); continue; } el.remove(); elements[handle] = undefined; }
dom|command|SET_INNER_HTML|set_inner_html|int32:handle string:html|{ const el = elements[handle]; if(el) el.innerHTML = html; }
dom|command|SET_INNER_TEXT|set_inner_text|int32:handle string:text|{ const el = elements[handle]; if(el) el.innerText = text; }
dom|command|ADD_CLASS|add_class|int32:handle string:cls|{ const el = elements[handle]; if(el) el.classList.add(cls); }
dom|command|REMOVE_CLASS|remove_class|int32:handle string:cls|{ const el = elements[handle]; if(el) el.classList.remove(cls); }
dom|event|CLICK|int32:handle
dom|command|ADD_CLICK_LISTENER|add_click_listener|int32:handle|{ const el = elements[handle]; if(el) el.addEventListener('click', () => push_event_dom_CLICK(handle)); }

# ------------------------------------------------------------------------------
# CANVAS 2D
# ------------------------------------------------------------------------------
canvas|command|CREATE_CANVAS|create_canvas|string:dom_id float32:width float32:height RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const c = document.createElement('canvas'); c.id = dom_id; c.width = width; c.height = height; elements[dom_id] = c; elements[handle] = c; return handle; }
canvas|command|GET_CONTEXT|get_context|int32:canvas_handle string:context_type RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const c = elements[canvas_handle]; if(!c) { console.warn('get_context: unknown canvas', canvas_handle); return 0; } contexts[handle] = c.getContext(context_type); return handle; }
canvas|command|SET_SIZE|set_size|int32:handle float32:width float32:height|{ const c = elements[handle]; if(c) { c.width = width; c.height = height; } }
canvas|command|SET_FILL_STYLE|set_fill_style|int32:handle uint8:r uint8:g uint8:b|{ const ctx = contexts[handle]; if(!ctx){ console.warn('set_fill_style: unknown context', handle); continue; } ctx.fillStyle = `rgb(${r},${g},${b})`; }
canvas|command|SET_FILL_STYLE_STR|set_fill_style_str|int32:handle string:color|{ const ctx = contexts[handle]; if(ctx) ctx.fillStyle = color; }
canvas|command|FILL_RECT|fill_rect|int32:handle float32:x float32:y float32:w float32:h|{ const ctx = contexts[handle]; if(!ctx){ console.warn('fill_rect: unknown context', handle); continue; } ctx.fillRect(x, y, w, h); }
canvas|command|CLEAR_RECT|clear_rect|int32:handle float32:x float32:y float32:w float32:h|{ const ctx = contexts[handle]; if(!ctx){ console.warn('clear_canvas: unknown context', handle); continue; } ctx.clearRect(x, y, w, h); }
canvas|command|STROKE_RECT|stroke_rect|int32:handle float32:x float32:y float32:w float32:h|{ const ctx = contexts[handle]; if(!ctx){ console.warn('stroke_rect: unknown context', handle); continue; } ctx.strokeRect(x, y, w, h); }
canvas|command|SET_STROKE_STYLE|set_stroke_style|int32:handle uint8:r uint8:g uint8:b|{ const ctx = contexts[handle]; if(!ctx){ console.warn('set_stroke_style: unknown context', handle); continue; } ctx.strokeStyle = `rgb(${r},${g},${b})`; }
canvas|command|SET_STROKE_STYLE_STR|set_stroke_style_str|int32:handle string:color|{ const ctx = contexts[handle]; if(ctx) ctx.strokeStyle = color; }
canvas|command|SET_LINE_WIDTH|set_line_width|int32:handle float32:width|{ const ctx = contexts[handle]; if(ctx) ctx.lineWidth = width; }
canvas|command|BEGIN_PATH|begin_path|int32:handle|{ const ctx = contexts[handle]; if(!ctx){ console.warn('begin_path: unknown context', handle); continue; } ctx.beginPath(); }
canvas|command|CLOSE_PATH|close_path|int32:handle|{ const ctx = contexts[handle]; if(ctx) ctx.closePath(); }
canvas|command|MOVE_TO|move_to|int32:handle float32:x float32:y|{ const ctx = contexts[handle]; if(!ctx){ console.warn('move_to: unknown context', handle); continue; } ctx.moveTo(x, y); }
canvas|command|LINE_TO|line_to|int32:handle float32:x float32:y|{ const ctx = contexts[handle]; if(!ctx){ console.warn('line_to: unknown context', handle); continue; } ctx.lineTo(x, y); }
canvas|command|STROKE|stroke|int32:handle|{ const ctx = contexts[handle]; if(!ctx){ console.warn('stroke: unknown context', handle); continue; } ctx.stroke(); }
canvas|command|FILL|fill|int32:handle|{ const ctx = contexts[handle]; if(!ctx){ console.warn('fill: unknown context', handle); continue; } ctx.fill(); }
canvas|command|ARC|arc|int32:handle float32:x float32:y float32:radius float32:start_angle float32:end_angle|{ const ctx = contexts[handle]; if(!ctx){ console.warn('arc: unknown context', handle); continue; } ctx.arc(x, y, radius, start_angle, end_angle); }
canvas|command|FILL_TEXT|fill_text|int32:handle string:text float32:x float32:y|{ const ctx = contexts[handle]; if(ctx) ctx.fillText(text, x, y); }
canvas|command|FILL_TEXT_F|fill_text_f|int32:handle string:fmt float32:val float32:x float32:y|{ const ctx = contexts[handle]; if(ctx) ctx.fillText(fmt.replace('%f', val.toFixed(2)), x, y); }
canvas|command|FILL_TEXT_I|fill_text_i|int32:handle string:fmt int32:val float32:x float32:y|{ const ctx = contexts[handle]; if(ctx) ctx.fillText(fmt.replace('%d', val), x, y); }
canvas|command|SET_FONT|set_font|int32:handle string:font|{ const ctx = contexts[handle]; if(ctx) ctx.font = font; }
canvas|command|SET_TEXT_ALIGN|set_text_align|int32:handle string:align|{ const ctx = contexts[handle]; if(ctx) ctx.textAlign = align; }
canvas|command|DRAW_IMAGE|draw_image|int32:handle int32:img_handle float32:x float32:y|{ const ctx = contexts[handle]; const img = images[img_handle]; if(ctx && img) ctx.drawImage(img, x, y); }
canvas|command|TRANSLATE|translate|int32:handle float32:x float32:y|{ const ctx = contexts[handle]; if(ctx) ctx.translate(x, y); }
canvas|command|ROTATE|rotate|int32:handle float32:angle|{ const ctx = contexts[handle]; if(ctx) ctx.rotate(angle); }
canvas|command|SCALE|scale|int32:handle float32:x float32:y|{ const ctx = contexts[handle]; if(ctx) ctx.scale(x, y); }
canvas|command|SAVE|save|int32:handle|{ const ctx = contexts[handle]; if(ctx) ctx.save(); }
canvas|command|RESTORE|restore|int32:handle|{ const ctx = contexts[handle]; if(ctx) ctx.restore(); }
canvas|command|LOG_CANVAS_INFO|log_canvas_info|int32:handle|{ const cv = elements[handle]; if(!cv){ console.warn('log_canvas_info: unknown canvas handle', handle); continue; } console.log('Canvas', handle, 'size:', cv.width, 'x', cv.height); }
canvas|command|SET_GLOBAL_ALPHA|set_global_alpha|int32:handle float32:alpha|{ const cv = elements[handle]; if(cv) cv.getContext('2d').globalAlpha = alpha; }
canvas|command|SET_LINE_CAP|set_line_cap|int32:handle string:cap|{ const cv = elements[handle]; if(cv) cv.getContext('2d').lineCap = cap; }
canvas|command|SET_LINE_JOIN|set_line_join|int32:handle string:join|{ const cv = elements[handle]; if(cv) cv.getContext('2d').lineJoin = join; }
canvas|command|SET_SHADOW|set_shadow|int32:handle float32:blur float32:off_x float32:off_y string:color|{ const cv = elements[handle]; if(cv) { const ctx = cv.getContext('2d'); ctx.shadowBlur = blur; ctx.shadowOffsetX = off_x; ctx.shadowOffsetY = off_y; ctx.shadowColor = color; } }
canvas|command|BEZIER_CURVE_TO|bezier_curve_to|int32:handle float32:cp1x float32:cp1y float32:cp2x float32:cp2y float32:x float32:y|{ const ctx = contexts[handle]; if(ctx) ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); }
canvas|command|QUADRATIC_CURVE_TO|quadratic_curve_to|int32:handle float32:cpx float32:cpy float32:x float32:y|{ const ctx = contexts[handle]; if(ctx) ctx.quadraticCurveTo(cpx, cpy, x, y); }
canvas|command|RECT|rect|int32:handle float32:x float32:y float32:w float32:h|{ const ctx = contexts[handle]; if(ctx) ctx.rect(x, y, w, h); }
canvas|command|CLIP|clip|int32:handle|{ const ctx = contexts[handle]; if(ctx) ctx.clip(); }
canvas|command|STROKE_TEXT|stroke_text|int32:handle string:text float32:x float32:y|{ const ctx = contexts[handle]; if(ctx) ctx.strokeText(text, x, y); }
canvas|command|SET_TEXT_BASELINE|set_text_baseline|int32:handle string:baseline|{ const ctx = contexts[handle]; if(ctx) ctx.textBaseline = baseline; }
canvas|command|SET_GLOBAL_COMPOSITE_OPERATION|set_global_composite_operation|int32:handle string:op|{ const ctx = contexts[handle]; if(ctx) ctx.globalCompositeOperation = op; }
canvas|command|DRAW_IMAGE_SCALED|draw_image_scaled|int32:handle int32:img_handle float32:x float32:y float32:w float32:h|{ const ctx = contexts[handle]; const img = images[img_handle]; if(ctx && img) ctx.drawImage(img, x, y, w, h); }
canvas|command|DRAW_IMAGE_FULL|draw_image_full|int32:handle int32:img_handle float32:sx float32:sy float32:sw float32:sh float32:dx float32:dy float32:dw float32:dh|{ const ctx = contexts[handle]; const img = images[img_handle]; if(ctx && img) ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh); }
canvas|command|RESET_TRANSFORM|reset_transform|int32:handle|{ const ctx = contexts[handle]; if(ctx) ctx.resetTransform(); }
canvas|command|ELLIPSE|ellipse|int32:handle float32:x float32:y float32:radius_x float32:radius_y float32:rotation float32:start_angle float32:end_angle uint8:counter_clockwise|{ const ctx = contexts[handle]; if(ctx) ctx.ellipse(x, y, radius_x, radius_y, rotation, start_angle, end_angle, counter_clockwise !== 0); }
canvas|command|ARC_TO|arc_to|int32:handle float32:x1 float32:y1 float32:x2 float32:y2 float32:radius|{ const ctx = contexts[handle]; if(ctx) ctx.arcTo(x1, y1, x2, y2, radius); }
canvas|command|SET_TRANSFORM|set_transform|int32:handle float32:a float32:b float32:c float32:d float32:e float32:f|{ const ctx = contexts[handle]; if(ctx) ctx.setTransform(a, b, c, d, e, f); }
canvas|command|TRANSFORM|transform|int32:handle float32:a float32:b float32:c float32:d float32:e float32:f|{ const ctx = contexts[handle]; if(ctx) ctx.transform(a, b, c, d, e, f); }
canvas|command|SET_MITER_LIMIT|set_miter_limit|int32:handle float32:limit|{ const ctx = contexts[handle]; if(ctx) ctx.miterLimit = limit; }
canvas|command|SET_IMAGE_SMOOTHING_ENABLED|set_image_smoothing_enabled|int32:handle uint8:enabled|{ const ctx = contexts[handle]; if(ctx) ctx.imageSmoothingEnabled = (enabled !== 0); }
canvas|command|MEASURE_TEXT_WIDTH|measure_text_width|int32:handle string:text RET:float32|{ const ctx = contexts[handle]; return (ctx ? ctx.measureText(text).width : 0); }

# ------------------------------------------------------------------------------
# INPUT
# ------------------------------------------------------------------------------
input|event|KEY_DOWN|int32:key_code
input|event|KEY_UP|int32:key_code
input|event|MOUSE_DOWN|int32:button int32:x int32:y
input|event|MOUSE_UP|int32:button int32:x int32:y
input|event|MOUSE_MOVE|int32:x int32:y
input|command|INIT_KEYBOARD|init_keyboard||{ window.addEventListener('keydown', e => push_event_input_KEY_DOWN(e.keyCode)); window.addEventListener('keyup', e => push_event_input_KEY_UP(e.keyCode)); }
input|command|INIT_MOUSE|init_mouse|int32:handle|{ const el = elements[handle] || document; el.addEventListener('mousedown', e => push_event_input_MOUSE_DOWN(e.button, e.offsetX, e.offsetY)); el.addEventListener('mouseup', e => push_event_input_MOUSE_UP(e.button, e.offsetX, e.offsetY)); el.addEventListener('mousemove', e => push_event_input_MOUSE_MOVE(e.offsetX, e.offsetY)); }
input|command|REQUEST_POINTER_LOCK|request_pointer_lock|int32:handle|{ const el = elements[handle] || document.body; el.requestPointerLock(); }
input|command|EXIT_POINTER_LOCK|exit_pointer_lock||{ document.exitPointerLock(); }

# ------------------------------------------------------------------------------
# SYSTEM
# ------------------------------------------------------------------------------
system|command|LOG|log|string:msg|{ console.log(msg); }
system|command|WARN|warn|string:msg|{ console.warn(msg); }
system|command|ERROR|error|string:msg|{ console.error(msg); }
system|command|SET_MAIN_LOOP|set_main_loop|func_ptr:func|{ const fn = table.get(func); if(!fn){ console.error('set_main_loop: function not found in table', func); continue; } const loop = (t) => { fn(t); requestAnimationFrame(loop); }; requestAnimationFrame(loop); }
system|command|SET_TITLE|set_title|string:title|{ document.title = title; }
system|command|RELOAD|reload||{ location.reload(); }
system|command|OPEN_URL|open_url|string:url|{ window.open(url, '_blank'); }
system|command|REQUEST_FULLSCREEN|request_fullscreen|int32:handle|{ const el = elements[handle] || document.body; el.requestFullscreen().catch(console.error); }

# ------------------------------------------------------------------------------
# STORAGE (LocalStorage)
# ------------------------------------------------------------------------------
storage|command|SET_ITEM|set_item|string:key string:value|{ localStorage.setItem(key, value); }
storage|command|REMOVE_ITEM|remove_item|string:key|{ localStorage.removeItem(key); }
storage|command|CLEAR|clear||{ localStorage.clear(); }

# ------------------------------------------------------------------------------
# AUDIO
# ------------------------------------------------------------------------------
audio|command|CREATE_AUDIO|create_audio|string:src RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const a = new Audio(src); audios[handle] = a; elements[handle] = a; return handle; }
audio|command|PLAY|play|int32:handle|{ const a = audios[handle]; if(a) a.play().catch(e => console.warn(e)); }
audio|command|PAUSE|pause|int32:handle|{ const a = audios[handle]; if(a) a.pause(); }
audio|command|SET_VOLUME|set_volume|int32:handle float32:vol|{ const a = audios[handle]; if(a) a.volume = vol; }
audio|command|SET_LOOP|set_loop|int32:handle uint8:loop|{ const a = audios[handle]; if(a) a.loop = (loop !== 0); }
audio|command|GET_CURRENT_TIME|get_current_time|int32:handle RET:float|{ const a = audios[handle]; return (a ? (a.currentTime || 0) : 0); }
audio|command|GET_DURATION|get_duration|int32:handle RET:float|{ const a = audios[handle]; return (a ? (a.duration || 0) : 0); }

# ------------------------------------------------------------------------------
# WEBSOCKETS
# ------------------------------------------------------------------------------
websocket|event|MESSAGE|int32:handle string:data
websocket|event|OPEN|int32:handle
websocket|event|CLOSE|int32:handle
websocket|event|ERROR|int32:handle

websocket|command|CREATE|create|string:url uint32:events RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const ws = new WebSocket(url); websockets[handle] = ws; if(events & 1) ws.onmessage = (e) => push_event_websocket_MESSAGE(handle, e.data); if(events & 2) ws.onopen = () => push_event_websocket_OPEN(handle); if(events & 4) ws.onclose = () => push_event_websocket_CLOSE(handle); if(events & 8) ws.onerror = () => push_event_websocket_ERROR(handle); return handle; }
websocket|command|SEND|send|int32:handle string:msg|{ const ws = websockets[handle]; if(ws && ws.readyState === 1) ws.send(msg); }
websocket|command|CLOSE|close|int32:handle|{ const ws = websockets[handle]; if(ws) ws.close(); }

# ------------------------------------------------------------------------------
# FETCH
# ------------------------------------------------------------------------------
fetch|event|SUCCESS|int32:id string:data
fetch|event|ERROR|int32:id string:error
fetch|command|GET|get|string:url RET:int32|{ const id = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); fetch(url).then(r => { if(!r.ok) throw new Error(r.status + ' ' + r.statusText); return r.text(); }).then(d => push_event_fetch_SUCCESS(id, d)).catch(e => push_event_fetch_ERROR(id, e.toString())); return id; }
fetch|command|POST|post|string:url string:body RET:int32|{ const id = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); fetch(url, { method: 'POST', body: body }).then(r => { if(!r.ok) throw new Error(r.status + ' ' + r.statusText); return r.text(); }).then(d => push_event_fetch_SUCCESS(id, d)).catch(e => push_event_fetch_ERROR(id, e.toString())); return id; }

# ------------------------------------------------------------------------------
# IMAGES
# ------------------------------------------------------------------------------
image|command|LOAD|load|string:src RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const img = new Image(); img.src = src; images[handle] = img; elements[handle] = img; return handle; }

# ------------------------------------------------------------------------------
# WEBGL
# ------------------------------------------------------------------------------
webgl|command|VIEWPORT|viewport|int32:ctx_handle int32:x int32:y int32:width int32:height|{ const gl = contexts[ctx_handle]; if(gl) gl.viewport(x, y, width, height); }
webgl|command|CLEAR_COLOR|clear_color|int32:ctx_handle float32:r float32:g float32:b float32:a|{ const gl = contexts[ctx_handle]; if(gl) gl.clearColor(r, g, b, a); }
webgl|command|CLEAR|clear|int32:ctx_handle uint32:mask|{ const gl = contexts[ctx_handle]; if(gl) gl.clear(mask); }
webgl|command|CREATE_SHADER|create_shader|int32:ctx_handle uint32:type string:source RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const gl = contexts[ctx_handle]; if(gl) { const s = gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s)); webgl_shaders[handle] = s; } return handle; }
webgl|command|CREATE_PROGRAM|create_program|int32:ctx_handle RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const gl = contexts[ctx_handle]; if(gl) { const p = gl.createProgram(); webgl_programs[handle] = p; } return handle; }
webgl|command|ATTACH_SHADER|attach_shader|int32:ctx_handle int32:prog_handle int32:shader_handle|{ const gl = contexts[ctx_handle]; const p = webgl_programs[prog_handle]; const s = webgl_shaders[shader_handle]; if(gl && p && s) gl.attachShader(p, s); }
webgl|command|LINK_PROGRAM|link_program|int32:ctx_handle int32:prog_handle|{ const gl = contexts[ctx_handle]; const p = webgl_programs[prog_handle]; if(gl && p) { gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p)); } }
webgl|command|BIND_ATTRIB_LOCATION|bind_attrib_location|int32:ctx_handle int32:prog_handle uint32:index string:name|{ const gl = contexts[ctx_handle]; const p = webgl_programs[prog_handle]; if(gl && p) gl.bindAttribLocation(p, index, name); }
webgl|command|USE_PROGRAM|use_program|int32:ctx_handle int32:prog_handle|{ const gl = contexts[ctx_handle]; const p = webgl_programs[prog_handle]; if(gl && p) gl.useProgram(p); }
webgl|command|CREATE_BUFFER|create_buffer|int32:ctx_handle RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const gl = contexts[ctx_handle]; if(gl) { const b = gl.createBuffer(); webgl_buffers[handle] = b; } return handle; }
webgl|command|BIND_BUFFER|bind_buffer|int32:ctx_handle uint32:target int32:buf_handle|{ const gl = contexts[ctx_handle]; const b = webgl_buffers[buf_handle]; if(gl && b) gl.bindBuffer(target, b); }
webgl|command|BUFFER_DATA|buffer_data|int32:ctx_handle uint32:target uint32:data_ptr uint32:data_len uint32:usage|{ const gl = contexts[ctx_handle]; if(gl) { const data = new Uint8Array(memory.buffer, data_ptr, data_len); gl.bufferData(target, data, usage); } }
webgl|command|ENABLE_VERTEX_ATTRIB_ARRAY|enable_vertex_attrib_array|int32:ctx_handle uint32:index|{ const gl = contexts[ctx_handle]; if(gl) gl.enableVertexAttribArray(index); }
webgl|command|ENABLE|enable|int32:ctx_handle uint32:cap|{ const gl = contexts[ctx_handle]; if(gl) gl.enable(cap); }
webgl|command|GET_UNIFORM_LOCATION|get_uniform_location|int32:ctx_handle int32:prog_handle string:name RET:int32|{ const handle = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); const gl = contexts[ctx_handle]; const p = webgl_programs[prog_handle]; if(gl && p) { const loc = gl.getUniformLocation(p, name); if(!loc) console.warn('getUniformLocation failed:', name); webgl_uniforms[handle] = loc; } return handle; }
webgl|command|UNIFORM_1F|uniform_1f|int32:ctx_handle int32:loc_handle float32:val|{ const gl = contexts[ctx_handle]; const loc = webgl_uniforms[loc_handle]; if(loc === undefined) console.warn('uniform_1f: loc undefined', loc_handle); if(gl && loc !== undefined) gl.uniform1f(loc, val); }
webgl|command|VERTEX_ATTRIB_POINTER|vertex_attrib_pointer|int32:ctx_handle uint32:index int32:size uint32:type uint8:normalized int32:stride int32:offset|{ const gl = contexts[ctx_handle]; if(gl) gl.vertexAttribPointer(index, size, type, normalized !== 0, stride, offset); }
webgl|command|DRAW_ARRAYS|draw_arrays|int32:ctx_handle uint32:mode int32:first int32:count|{ const gl = contexts[ctx_handle]; if(gl) gl.drawArrays(mode, first, count); }

# ------------------------------------------------------------------------------
# WEBGPU
# ------------------------------------------------------------------------------
wgpu|event|ADAPTER_READY|int32:handle
wgpu|event|DEVICE_READY|int32:handle
wgpu|command|REQUEST_ADAPTER|request_adapter||{ if (!navigator.gpu) { console.warn('NO: navigator.gpu is undefined — WebGPU not available'); push_event_wgpu_ADAPTER_READY(0); return; } console.log('navigator.gpu OK'); navigator.gpu.requestAdapter({ powerPreference: 'high-performance' }).then(a => a || navigator.gpu.requestAdapter()).then(adapter => { if (!adapter) { console.warn('NO: requestAdapter returned null — no usable adapter'); push_event_wgpu_ADAPTER_READY(0); return; } console.log('Adapter:', adapter); console.log('Features:', Array.from(adapter.features || [])); console.log('Limits:', adapter.limits || {}); const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_adapters[h] = adapter; push_event_wgpu_ADAPTER_READY(h); }).catch(e => { console.error('requestAdapter failed:', e); push_event_wgpu_ADAPTER_READY(0); }); }
wgpu|command|REQUEST_DEVICE|request_device|int32:adapter_handle|{ const a = webgpu_adapters[adapter_handle]; if(a) a.requestDevice().then(d => { const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_devices[h] = d; webgpu_queues[h] = d.queue; push_event_wgpu_DEVICE_READY(h); }).catch(e => console.error("WebGPU: requestDevice failed", e)); }
wgpu|command|GET_QUEUE|get_queue|int32:device_handle RET:int32|{ const d = webgpu_devices[device_handle]; if(!d) return 0; const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_queues[h] = d.queue; return h; }
wgpu|command|CREATE_SHADER_MODULE|create_shader_module|int32:device_handle string:code RET:int32|{ const d = webgpu_devices[device_handle]; if(!d) return 0; const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_shaders[h] = d.createShaderModule({ code: code }); return h; }
wgpu|command|CREATE_COMMAND_ENCODER|create_command_encoder|int32:device_handle RET:int32|{ const d = webgpu_devices[device_handle]; if(!d) return 0; const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_encoders[h] = d.createCommandEncoder(); return h; }
wgpu|command|CONFIGURE|configure|int32:context_handle int32:device_handle string:format|{ const ctx = contexts[context_handle]; const dev = webgpu_devices[device_handle]; if(ctx && dev) ctx.configure({ device: dev, format: format === 'preferred' ? navigator.gpu.getPreferredCanvasFormat() : format, alphaMode: 'premultiplied' }); }
wgpu|command|GET_CURRENT_TEXTURE_VIEW|get_current_texture_view|int32:context_handle RET:int32|{ const ctx = contexts[context_handle]; if(!ctx) return 0; const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_views[h] = ctx.getCurrentTexture().createView(); return h; }
wgpu|command|BEGIN_RENDER_PASS|begin_render_pass|int32:encoder_handle int32:view_handle float32:r float32:g float32:b float32:a RET:int32|{ const enc = webgpu_encoders[encoder_handle]; const view = webgpu_views[view_handle]; if(!enc || !view) return 0; const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_passes[h] = enc.beginRenderPass({ colorAttachments: [{ view: view, clearValue: {r, g, b, a}, loadOp: 'clear', storeOp: 'store' }] }); return h; }
wgpu|command|END_PASS|end_pass|int32:pass_handle|{ const pass = webgpu_passes[pass_handle]; if(pass) pass.end(); }
wgpu|command|FINISH_ENCODER|finish_encoder|int32:encoder_handle RET:int32|{ const enc = webgpu_encoders[encoder_handle]; if(!enc) return 0; const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_buffers[h] = enc.finish(); return h; }
wgpu|command|QUEUE_SUBMIT|queue_submit|int32:queue_handle int32:command_buffer_handle|{ const q = webgpu_queues[queue_handle]; const cb = webgpu_buffers[command_buffer_handle]; if(q && cb) q.submit([cb]); }
wgpu|command|CREATE_RENDER_PIPELINE_SIMPLE|create_render_pipeline_simple|int32:device_handle int32:vs_module_handle int32:fs_module_handle string:vs_entry string:fs_entry string:format RET:int32|{ const d = webgpu_devices[device_handle]; const vs = webgpu_shaders[vs_module_handle]; const fs = webgpu_shaders[fs_module_handle]; if(!d || !vs || !fs) return 0; const h = (window.webcc_next_id = (window.webcc_next_id || 0) + 1); webgpu_pipelines[h] = d.createRenderPipeline({ layout: 'auto', vertex: { module: vs, entryPoint: vs_entry }, fragment: { module: fs, entryPoint: fs_entry, targets: [{ format: format === 'preferred' ? navigator.gpu.getPreferredCanvasFormat() : format }] }, primitive: { topology: 'triangle-list' } }); return h; }
wgpu|command|SET_PIPELINE|set_pipeline|int32:pass_handle int32:pipeline_handle|{ const pass = webgpu_passes[pass_handle]; const pipe = webgpu_pipelines[pipeline_handle]; if(pass && pipe) pass.setPipeline(pipe); }
wgpu|command|DRAW|draw|int32:pass_handle int32:vertex_count int32:instance_count int32:first_vertex int32:first_instance|{ const pass = webgpu_passes[pass_handle]; if(pass) pass.draw(vertex_count, instance_count, first_vertex, first_instance); }
